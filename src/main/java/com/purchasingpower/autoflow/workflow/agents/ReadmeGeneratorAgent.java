package com.purchasingpower.autoflow.workflow.agents;

import com.purchasingpower.autoflow.client.GeminiClient;
import com.purchasingpower.autoflow.service.PromptLibraryService;
import com.purchasingpower.autoflow.workflow.state.*;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Component;

import java.util.HashMap;
import java.util.Map;
import java.util.stream.Collectors;

/**
 * AGENT 9: README Generator
 *
 * Purpose: Generate comprehensive PR description
 *
 * USES PROMPT LIBRARY (no hardcoded prompts!)
 *
 * Includes:
 * - Summary
 * - Root cause (for bugs)
 * - Changes made
 * - Impact assessment
 * - Testing strategy
 * - Rollback plan
 */
@Slf4j
@Component
@RequiredArgsConstructor
public class ReadmeGeneratorAgent {

    private final GeminiClient geminiClient;
    private final PromptLibraryService promptLibrary;

    public AgentDecision execute(WorkflowState state) {
        log.info("ðŸ“ Generating PR README...");

        try {
            String readme = generateReadmeWithLLM(state);
            state.setPrDescription(readme);

            log.info("âœ… PR README generated ({} chars)", readme.length());

            return AgentDecision.proceed("README generated, creating PR");

        } catch (Exception e) {
            log.error("README generation failed", e);

            // Create fallback README
            String fallback = createFallbackReadme(state);
            state.setPrDescription(fallback);

            return AgentDecision.proceed("Using fallback README");
        }
    }

    /**
     * Generate README with LLM using PROMPT LIBRARY
     */
    private String generateReadmeWithLLM(WorkflowState state) {
        // Prepare files modified list
        var filesModified = state.getGeneratedCode().getEdits().stream()
                .map(edit -> Map.of("path", (Object) edit.getPath()))
                .toList();

        // Prepare files created list
        var filesCreated = state.getScopeProposal().getFilesToCreate().stream()
                .map(action -> Map.of("path", (Object) action.getFilePath()))
                .toList();

        // Prepare variables for prompt template
        Map<String, Object> variables = new HashMap<>();
        variables.put("requirement", state.getRequirement());
        variables.put("taskType", state.getRequirementAnalysis().getTaskType());
        variables.put("filesModified", filesModified);
        variables.put("filesCreated", filesCreated);
        variables.put("explanation", state.getGeneratedCode().getExplanation());

        if (state.getLogAnalysis() != null) {
            variables.put("logAnalysis", Map.of(
                    "rootCauseHypothesis", state.getLogAnalysis().getRootCauseHypothesis()
            ));
        }

        if (state.getTestResult() != null) {
            variables.put("testsPassed", state.getTestResult().getTestsPassed());
            variables.put("coverageDelta", state.getTestResult().getCoverageDelta());
        }

        if (state.getCodeReview() != null) {
            variables.put("qualityScore", state.getCodeReview().getQualityScore());
        }

        // Render prompt using PROMPT LIBRARY
        String prompt = promptLibrary.render("readme-generator", variables);

        // Call LLM
        return geminiClient.generateText(prompt);
    }

    /**
     * Fallback README if LLM fails
     */
    private String createFallbackReadme(WorkflowState state) {
        return String.format("""
            # %s
            
            ## Summary
            %s
            
            ## Changes Made
            - Modified %d files
            - Created %d files
            - Added/updated %d tests
            
            ## Testing
            %s
            
            ---
            _Generated by AutoFlow AI_
            """,
                state.getRequirement(),
                state.getRequirementAnalysis().getSummary(),
                state.getGeneratedCode().getEdits().size(),
                state.getScopeProposal().getFilesToCreate().size(),
                state.getGeneratedCode().getTestsAdded().size(),
                state.getTestResult() != null && state.getTestResult().isAllTestsPassed() ?
                        "All tests passed âœ…" : "Some tests may need attention"
        );
    }
}