package com.purchasingpower.autoflow.service;

import com.purchasingpower.autoflow.client.GeminiClient;
import com.purchasingpower.autoflow.model.retrieval.CodeContext;
import com.purchasingpower.autoflow.model.retrieval.RetrievalPlan;
import com.purchasingpower.autoflow.model.retrieval.RetrievalStrategy;
import com.purchasingpower.autoflow.repository.GraphNodeRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

/**
 * DynamicRetrievalExecutor - Executes retrieval plans dynamically.
 *
 * Takes a RetrievalPlan (generated by LLM) and executes each strategy,
 * combining results intelligently.
 *
 * ‚úÖ UPDATED: Now uses Neo4j CypherQueryService instead of Pinecone.
 *
 * Supported strategies:
 * - metadata_filter: Filter by annotations, class names, file paths (Neo4j)
 * - semantic_search: Full-text search on code content (Neo4j)
 * - file_pattern: Match specific file paths (Neo4j)
 * - broad_overview: Get high-level project structure (Neo4j)
 * - cypher_query: Direct Cypher query execution (Neo4j)
 * - graph_traversal: Follow dependencies in Neo4j
 * - cross_repo_api: Find API contracts
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class DynamicRetrievalExecutor {

    private final CypherQueryService cypherQueryService;
    private final GeminiClient geminiClient;
    private final GraphNodeRepository graphNodeRepository;

    /**
     * Execute a retrieval plan and return combined results.
     *
     * @param plan Retrieval plan to execute
     * @return List of retrieved code chunks (deduplicated and ranked)
     */
    public List<CodeContext> execute(RetrievalPlan plan) {
        log.info("üöÄ Executing retrieval plan with {} strategies", plan.getStrategyCount());

        List<CodeContext> allResults = new ArrayList<>();
        int strategyNum = 0;

        // Execute each strategy in order
        for (RetrievalStrategy strategy : plan.getStrategies()) {
            strategyNum++;
            log.info("  [{}/{}] Executing: {} - {}",
                strategyNum, plan.getStrategyCount(),
                strategy.getType(), strategy.getReasoning());

            try {
                List<CodeContext> results = executeStrategy(strategy);
                log.info("    ‚úÖ Retrieved {} chunks", results.size());
                allResults.addAll(results);

            } catch (Exception e) {
                log.error("    ‚ùå Strategy failed: {}", strategy.getType(), e);
                // Continue with other strategies even if one fails
            }
        }

        // Deduplicate and rank results
        List<CodeContext> finalResults = deduplicateAndRank(allResults);
        log.info("‚úÖ Total retrieved: {} chunks (after deduplication)", finalResults.size());

        return finalResults;
    }

    /**
     * Execute a single retrieval strategy.
     */
    private List<CodeContext> executeStrategy(RetrievalStrategy strategy) {
        return switch (strategy.getType()) {
            case "metadata_filter" -> executeMetadataFilter(strategy);
            case "semantic_search" -> executeSemanticSearch(strategy);
            case "file_pattern" -> executeFilePattern(strategy);
            case "broad_overview" -> executeBroadOverview(strategy);
            case "graph_traversal" -> executeGraphTraversal(strategy);
            case "cross_repo_api" -> executeCrossRepoApi(strategy);
            default -> {
                log.warn("    ‚ö†Ô∏è Unknown strategy type: {}", strategy.getType());
                yield List.of();
            }
        };
    }

    /**
     * Execute metadata_filter strategy.
     *
     * Filters code by annotations, class names, or file paths using Neo4j.
     */
    private List<CodeContext> executeMetadataFilter(RetrievalStrategy strategy) {
        String repoName = strategy.getTargetRepos().isEmpty()
            ? null : strategy.getTargetRepos().get(0);

        Map<String, Object> params = strategy.getParameters();

        // Build metadata filters
        Map<String, String> filters = new HashMap<>();

        if (params.containsKey("annotations")) {
            filters.put("annotations", (String) params.get("annotations"));
        }

        if (params.containsKey("className_contains")) {
            filters.put("className_contains", (String) params.get("className_contains"));
        }

        if (params.containsKey("package")) {
            filters.put("package", (String) params.get("package"));
        }

        // ‚úÖ Use Neo4j metadata query (precise, no embeddings needed!)
        return cypherQueryService.queryByMetadata(repoName, filters);
    }

    /**
     * Execute semantic_search strategy.
     *
     * ‚úÖ UPDATED: Uses Neo4j full-text search instead of embeddings.
     * More accurate for code search (exact matches, no fuzzy similarity).
     */
    private List<CodeContext> executeSemanticSearch(RetrievalStrategy strategy) {
        String query = strategy.getRequiredParameter("query");
        Integer topK = strategy.getParameter("top_k", 20);

        String repoName = strategy.getTargetRepos().isEmpty()
            ? null : strategy.getTargetRepos().get(0);

        // ‚úÖ Use Neo4j full-text search (CONTAINS on sourceCode, summary, javadoc)
        return cypherQueryService.fullTextSearch(repoName, query, topK);
    }

    /**
     * Execute file_pattern strategy.
     *
     * Match specific file paths (README, pom.xml, etc.) using Neo4j regex.
     */
    private List<CodeContext> executeFilePattern(RetrievalStrategy strategy) {
        String pattern = strategy.getRequiredParameter("pattern");
        String repoName = strategy.getTargetRepos().isEmpty()
            ? null : strategy.getTargetRepos().get(0);

        // ‚úÖ Use Neo4j file pattern query (regex on sourceFilePath)
        return cypherQueryService.queryByFilePattern(repoName, pattern);
    }

    /**
     * Execute broad_overview strategy.
     *
     * ‚úÖ UPDATED: Get high-level project structure using Neo4j queries.
     * No embeddings needed - just precise metadata/file path queries.
     */
    private List<CodeContext> executeBroadOverview(RetrievalStrategy strategy) {
        String repoName = strategy.getTargetRepos().isEmpty()
            ? null : strategy.getTargetRepos().get(0);

        List<CodeContext> results = new ArrayList<>();

        // Strategy 1: Find README files
        List<CodeContext> readmeResults = cypherQueryService.queryByFilePattern(repoName, "README");
        results.addAll(readmeResults.stream().limit(1).toList());

        // Strategy 2: Find main application class (@SpringBootApplication, main method)
        Map<String, String> mainClassFilters = Map.of("annotations", "@SpringBootApplication");
        List<CodeContext> mainResults = cypherQueryService.queryByMetadata(repoName, mainClassFilters);
        results.addAll(mainResults.stream().limit(2).toList());

        // Strategy 3: Find build files (pom.xml or build.gradle)
        List<CodeContext> pomResults = cypherQueryService.queryByFilePattern(repoName, "pom\\.xml");
        results.addAll(pomResults.stream().limit(1).toList());

        if (pomResults.isEmpty()) {
            List<CodeContext> gradleResults = cypherQueryService.queryByFilePattern(repoName, "build\\.gradle");
            results.addAll(gradleResults.stream().limit(1).toList());
        }

        return results;
    }

    /**
     * Execute graph_traversal strategy.
     *
     * Follow dependencies in Neo4j code graph.
     */
    private List<CodeContext> executeGraphTraversal(RetrievalStrategy strategy) {
        // TODO: Implement Neo4j graph traversal
        log.warn("    ‚ö†Ô∏è graph_traversal not implemented yet");
        return List.of();
    }

    /**
     * Execute cross_repo_api strategy.
     *
     * Find API contracts between services.
     */
    private List<CodeContext> executeCrossRepoApi(RetrievalStrategy strategy) {
        // TODO: Implement cross-repo API discovery
        log.warn("    ‚ö†Ô∏è cross_repo_api not implemented yet");
        return List.of();
    }

    /**
     * Deduplicate and rank results.
     *
     * - Remove duplicates (by chunk ID)
     * - Sort by relevance score
     * - Limit to reasonable number
     */
    private List<CodeContext> deduplicateAndRank(List<CodeContext> results) {
        // Deduplicate by chunk ID
        Map<String, CodeContext> uniqueResults = new LinkedHashMap<>();
        for (CodeContext code : results) {
            String id = code.id();
            if (!uniqueResults.containsKey(id)) {
                uniqueResults.put(id, code);
            }
        }

        // Sort by score (descending)
        return uniqueResults.values().stream()
            .sorted((a, b) -> Float.compare(b.score(), a.score()))
            .limit(50)  // Reasonable limit
            .collect(Collectors.toList());
    }
}
