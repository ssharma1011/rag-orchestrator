package com.purchasingpower.autoflow.model.metrics;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Builder;
import lombok.Data;
import lombok.NoArgsConstructor;

import java.time.LocalDateTime;

/**
 * AgentExecution - Tracks every agent execution for observability.
 *
 * This entity captures detailed metrics about each agent's execution:
 * - Performance metrics (latency, token usage)
 * - Decision tracking (what did the agent decide?)
 * - Error tracking (what went wrong?)
 * - State snapshots (input/output for debugging)
 *
 * Use cases:
 * 1. Debugging: "What happened in this workflow?"
 * 2. Performance monitoring: "Which agents are slow?"
 * 3. Cost tracking: "How many tokens did we use?"
 * 4. Analytics: "What decisions do agents make most often?"
 */
@Data
@Entity
@Table(name = "AGENT_EXECUTIONS")
@Builder
@NoArgsConstructor
@AllArgsConstructor
public class AgentExecution {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    @Column(name = "id")
    private Long id;

    /**
     * Unique identifier for this specific agent execution (UUID).
     */
    @Column(name = "execution_id", nullable = false, unique = true, length = 50)
    private String executionId;

    /**
     * Which conversation this execution belongs to.
     */
    @Column(name = "conversation_id", nullable = false, length = 50)
    private String conversationId;

    /**
     * Name of the agent that executed.
     * Example: "RequirementAnalyzerAgent", "CodeGeneratorAgent"
     */
    @Column(name = "agent_name", nullable = false, length = 100)
    private String agentName;

    /**
     * WorkflowState snapshot BEFORE agent execution (JSON).
     * Useful for debugging and understanding what the agent received as input.
     */
    @Lob
    @Column(name = "input_state", columnDefinition = "CLOB")
    private String inputState;

    /**
     * WorkflowState snapshot AFTER agent execution (JSON).
     * Shows what changes the agent made to the state.
     */
    @Lob
    @Column(name = "output_state", columnDefinition = "CLOB")
    private String outputState;

    /**
     * Agent's decision: PROCEED, ASK_DEV, ERROR, RETRY, END_SUCCESS, END_FAILURE.
     */
    @Column(name = "decision", length = 50)
    private String decision;

    /**
     * Confidence score (0.00 - 1.00).
     * How confident was the agent in its decision?
     */
    @Column(name = "confidence", precision = 3, scale = 2)
    private Double confidence;

    /**
     * LLM input tokens consumed by this agent.
     * Used for cost tracking.
     */
    @Column(name = "token_usage_input")
    private Integer tokenUsageInput;

    /**
     * LLM output tokens generated by this agent.
     * Used for cost tracking.
     */
    @Column(name = "token_usage_output")
    private Integer tokenUsageOutput;

    /**
     * Agent execution time in milliseconds.
     * Used for performance monitoring.
     */
    @Column(name = "latency_ms")
    private Long latencyMs;

    /**
     * Execution status: SUCCESS, FAILED, TIMEOUT, etc.
     */
    @Column(name = "status", length = 50)
    private String status;

    /**
     * Error message if status = FAILED.
     */
    @Column(name = "error_message", length = 4000)
    private String errorMessage;

    /**
     * When this execution happened.
     */
    @Column(name = "created_at", nullable = false)
    private LocalDateTime createdAt;

    // ================================================================
    // Lifecycle Hooks
    // ================================================================

    @PrePersist
    public void prePersist() {
        if (createdAt == null) {
            createdAt = LocalDateTime.now();
        }
    }

    // ================================================================
    // Helper Methods
    // ================================================================

    /**
     * Get total tokens used (input + output).
     */
    public Integer getTotalTokens() {
        int input = tokenUsageInput != null ? tokenUsageInput : 0;
        int output = tokenUsageOutput != null ? tokenUsageOutput : 0;
        return input + output;
    }

    /**
     * Check if this execution was successful.
     */
    public boolean wasSuccessful() {
        return "SUCCESS".equals(status);
    }

    /**
     * Check if this execution failed.
     */
    public boolean failed() {
        return "FAILED".equals(status);
    }

    /**
     * Get latency in seconds.
     */
    public Double getLatencySec() {
        if (latencyMs == null) {
            return null;
        }
        return latencyMs / 1000.0;
    }

    /**
     * Builder helper to set success status.
     */
    public static class AgentExecutionBuilder {
        public AgentExecutionBuilder success() {
            this.status = "SUCCESS";
            return this;
        }

        public AgentExecutionBuilder failed(String errorMsg) {
            this.status = "FAILED";
            this.errorMessage = errorMsg;
            return this;
        }
    }
}
