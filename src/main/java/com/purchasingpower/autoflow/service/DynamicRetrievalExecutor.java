package com.purchasingpower.autoflow.service;

import com.purchasingpower.autoflow.client.GeminiClient;
import com.purchasingpower.autoflow.client.PineconeRetriever;
import com.purchasingpower.autoflow.model.retrieval.CodeContext;
import com.purchasingpower.autoflow.model.retrieval.RetrievalPlan;
import com.purchasingpower.autoflow.model.retrieval.RetrievalStrategy;
import com.purchasingpower.autoflow.repository.GraphNodeRepository;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

import java.util.*;
import java.util.stream.Collectors;

/**
 * DynamicRetrievalExecutor - Executes retrieval plans dynamically.
 *
 * Takes a RetrievalPlan (generated by LLM) and executes each strategy,
 * combining results intelligently.
 *
 * Supported strategies:
 * - metadata_filter: Filter by annotations, class names, file paths
 * - semantic_search: Embedding-based similarity
 * - file_pattern: Match specific file paths (README, pom.xml, etc.)
 * - broad_overview: Get high-level project structure
 * - (future) graph_traversal: Follow dependencies in Neo4j
 * - (future) cross_repo_api: Find API contracts
 */
@Slf4j
@Service
@RequiredArgsConstructor
public class DynamicRetrievalExecutor {

    private final PineconeRetriever pineconeRetriever;
    private final GeminiClient geminiClient;
    private final GraphNodeRepository graphNodeRepository;

    /**
     * Execute a retrieval plan and return combined results.
     *
     * @param plan Retrieval plan to execute
     * @return List of retrieved code chunks (deduplicated and ranked)
     */
    public List<CodeContext> execute(RetrievalPlan plan) {
        log.info("üöÄ Executing retrieval plan with {} strategies", plan.getStrategyCount());

        List<CodeContext> allResults = new ArrayList<>();
        int strategyNum = 0;

        // Execute each strategy in order
        for (RetrievalStrategy strategy : plan.getStrategies()) {
            strategyNum++;
            log.info("  [{}/{}] Executing: {} - {}",
                strategyNum, plan.getStrategyCount(),
                strategy.getType(), strategy.getReasoning());

            try {
                List<CodeContext> results = executeStrategy(strategy);
                log.info("    ‚úÖ Retrieved {} chunks", results.size());
                allResults.addAll(results);

            } catch (Exception e) {
                log.error("    ‚ùå Strategy failed: {}", strategy.getType(), e);
                // Continue with other strategies even if one fails
            }
        }

        // Deduplicate and rank results
        List<CodeContext> finalResults = deduplicateAndRank(allResults);
        log.info("‚úÖ Total retrieved: {} chunks (after deduplication)", finalResults.size());

        return finalResults;
    }

    /**
     * Execute a single retrieval strategy.
     */
    private List<CodeContext> executeStrategy(RetrievalStrategy strategy) {
        return switch (strategy.getType()) {
            case "metadata_filter" -> executeMetadataFilter(strategy);
            case "semantic_search" -> executeSemanticSearch(strategy);
            case "file_pattern" -> executeFilePattern(strategy);
            case "broad_overview" -> executeBroadOverview(strategy);
            case "graph_traversal" -> executeGraphTraversal(strategy);
            case "cross_repo_api" -> executeCrossRepoApi(strategy);
            default -> {
                log.warn("    ‚ö†Ô∏è Unknown strategy type: {}", strategy.getType());
                yield List.of();
            }
        };
    }

    /**
     * Execute metadata_filter strategy.
     *
     * Filters code by annotations, class names, or file paths.
     */
    private List<CodeContext> executeMetadataFilter(RetrievalStrategy strategy) {
        String repoName = strategy.getTargetRepos().isEmpty()
            ? null : strategy.getTargetRepos().get(0);

        Map<String, Object> params = strategy.getParameters();

        // Build metadata filters
        Map<String, String> filters = new HashMap<>();

        if (params.containsKey("annotations")) {
            filters.put("annotations", (String) params.get("annotations"));
        }

        if (params.containsKey("className_contains")) {
            filters.put("className_contains", (String) params.get("className_contains"));
        }

        if (params.containsKey("filePath_pattern")) {
            filters.put("filePath_pattern", (String) params.get("filePath_pattern"));
        }

        // Query Pinecone with metadata filter
        // TODO: Implement pineconeRetriever.queryByMetadata()
        // For now, fall back to semantic search with domain filtering
        log.warn("    ‚ö†Ô∏è metadata_filter not fully implemented yet, using semantic search fallback");

        String queryString = buildQueryFromFilters(filters);
        List<Double> embedding = geminiClient.createEmbedding(queryString);

        return pineconeRetriever.findRelevantCodeStructured(embedding, repoName);
    }

    /**
     * Execute semantic_search strategy.
     *
     * Standard embedding-based similarity search.
     */
    private List<CodeContext> executeSemanticSearch(RetrievalStrategy strategy) {
        String query = strategy.getRequiredParameter("query");
        Integer topK = strategy.getParameter("top_k", 20);

        String repoName = strategy.getTargetRepos().isEmpty()
            ? null : strategy.getTargetRepos().get(0);

        // Create embedding for query
        List<Double> queryEmbedding = geminiClient.createEmbedding(query);

        // Search Pinecone
        List<CodeContext> results = pineconeRetriever.findRelevantCodeStructured(
            queryEmbedding,
            repoName
        );

        // Limit to topK
        return results.stream()
            .limit(topK)
            .collect(Collectors.toList());
    }

    /**
     * Execute file_pattern strategy.
     *
     * Match specific file paths (README, pom.xml, etc.)
     */
    private List<CodeContext> executeFilePattern(RetrievalStrategy strategy) {
        String pattern = strategy.getRequiredParameter("pattern");
        String repoName = strategy.getTargetRepos().isEmpty()
            ? null : strategy.getTargetRepos().get(0);

        // TODO: Implement pineconeRetriever.queryByFilePattern()
        // For now, use semantic search with file-focused query
        log.warn("    ‚ö†Ô∏è file_pattern not fully implemented yet, using semantic search fallback");

        String query = "file content from " + pattern;
        List<Double> embedding = geminiClient.createEmbedding(query);

        return pineconeRetriever.findRelevantCodeStructured(embedding, repoName).stream()
            .filter(code -> code.filePath() != null && code.filePath().matches(".*" + pattern + ".*"))
            .collect(Collectors.toList());
    }

    /**
     * Execute broad_overview strategy.
     *
     * Get high-level project structure (README + main classes + build files).
     */
    private List<CodeContext> executeBroadOverview(RetrievalStrategy strategy) {
        String repoName = strategy.getTargetRepos().isEmpty()
            ? null : strategy.getTargetRepos().get(0);

        List<CodeContext> results = new ArrayList<>();

        // Strategy 1: Find README
        String readmeQuery = "project README documentation overview";
        List<Double> readmeEmbedding = geminiClient.createEmbedding(readmeQuery);
        List<CodeContext> readmeResults = pineconeRetriever.findRelevantCodeStructured(
            readmeEmbedding, repoName
        ).stream()
            .filter(code -> code.filePath() != null &&
                           code.filePath().toLowerCase().contains("readme"))
            .limit(1)
            .toList();
        results.addAll(readmeResults);

        // Strategy 2: Find main application class
        String mainClassQuery = "main application entry point SpringBootApplication";
        List<Double> mainEmbedding = geminiClient.createEmbedding(mainClassQuery);
        List<CodeContext> mainResults = pineconeRetriever.findRelevantCodeStructured(
            mainEmbedding, repoName
        ).stream()
            .filter(code -> code.className() != null &&
                           (code.className().contains("Application") ||
                            code.className().contains("Main")))
            .limit(2)
            .toList();
        results.addAll(mainResults);

        // Strategy 3: Find build file (pom.xml or build.gradle)
        String buildQuery = "project dependencies build configuration pom.xml";
        List<Double> buildEmbedding = geminiClient.createEmbedding(buildQuery);
        List<CodeContext> buildResults = pineconeRetriever.findRelevantCodeStructured(
            buildEmbedding, repoName
        ).stream()
            .filter(code -> code.filePath() != null &&
                           (code.filePath().contains("pom.xml") ||
                            code.filePath().contains("build.gradle")))
            .limit(1)
            .toList();
        results.addAll(buildResults);

        return results;
    }

    /**
     * Execute graph_traversal strategy.
     *
     * Follow dependencies in Neo4j code graph.
     */
    private List<CodeContext> executeGraphTraversal(RetrievalStrategy strategy) {
        // TODO: Implement Neo4j graph traversal
        log.warn("    ‚ö†Ô∏è graph_traversal not implemented yet");
        return List.of();
    }

    /**
     * Execute cross_repo_api strategy.
     *
     * Find API contracts between services.
     */
    private List<CodeContext> executeCrossRepoApi(RetrievalStrategy strategy) {
        // TODO: Implement cross-repo API discovery
        log.warn("    ‚ö†Ô∏è cross_repo_api not implemented yet");
        return List.of();
    }

    /**
     * Build a search query string from metadata filters.
     */
    private String buildQueryFromFilters(Map<String, String> filters) {
        StringBuilder query = new StringBuilder();

        if (filters.containsKey("annotations")) {
            query.append(filters.get("annotations").replace(",", " ")).append(" ");
        }

        if (filters.containsKey("className_contains")) {
            query.append(filters.get("className_contains")).append(" ");
        }

        return query.toString().trim();
    }

    /**
     * Deduplicate and rank results.
     *
     * - Remove duplicates (by chunk ID)
     * - Sort by relevance score
     * - Limit to reasonable number
     */
    private List<CodeContext> deduplicateAndRank(List<CodeContext> results) {
        // Deduplicate by chunk ID
        Map<String, CodeContext> uniqueResults = new LinkedHashMap<>();
        for (CodeContext code : results) {
            String id = code.id();
            if (!uniqueResults.containsKey(id)) {
                uniqueResults.put(id, code);
            }
        }

        // Sort by score (descending)
        return uniqueResults.values().stream()
            .sorted((a, b) -> Float.compare(b.score(), a.score()))
            .limit(50)  // Reasonable limit
            .collect(Collectors.toList());
    }
}
